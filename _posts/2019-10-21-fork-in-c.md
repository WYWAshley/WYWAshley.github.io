---
layout: post
title: Fork() In C & Child Process 
categories: [c, linux kernel, system call]
description: a brief introduction of how OS and C program deal with the child proccess created by fork()
keywords: fork, linux, c
---

## When and How to deal with child process forked

### problem in fork()

我在进行 [cgroup escape 实验](https://tianyuzhou.top/2019/10/18/cgroups-escape/)的时候，发现 exploit 程序不同写法会导致不同的结果，具体的代码如下所示

```c
#include <stdio.h>
#include <unistd.h>
int main() {
	while(1) {
		int pid = fork();
		if(pid > 0) {	// in father proccess
			int i = 1 / 0;	// make interrupt
			return 0;
		}
    }   
    return 0;
}
```

这段代码做了几件事

* 生成子进程，然后父进程自己触发 core dump
* 子进程继续生成孙子进程，子进程再触发 core dump
* 子子孙孙都如上进行先 `fork()` 再 `int i = 1/0` 的操作

上面的程序，即使在运行 docker container 的时候加上了 pid 的限制，依旧可以实现 cgroup escape，即占满 Host 的 cpu 资源。从结果上看，即 fork 操作是一直在进行的。

然而如果**换了一种写法**，结果将大不相同

```c
#include <stdio.h>
#include <unistd.h>
int main() {
	while(1) {
		int pid = fork();
		if(pid == 0) {	// in child proccess
			int i = 1 / 0;	// make interrupt
			return 0;
		}
    }   
    return 0;
}
```

这里仅仅将判断条件改为了 `pid == 0`，目的是将执行逻辑改变，现在仅由父进程来进行 `fork()` 操作，子进程来进行 `i = 1/0` 操作触发 core dump。按照我的设想，这两个程序的功能是一致的，子进程触发 core dump 之后直接终止，因此父进程可以在子进程资源释放之后再次进行 `fork()` 操作（如果当前运行进程已经达到 cgroup 限制）。

但是从结果上看，在父进程 `fork()` 出达到限制的进程数目之后，即使子进程已经终止，父进程依然无法 `fork()` 出新的进程。

我设法找到了那些我认为已经释放资源的子进程

```
  834 pts/0    00:00:00 do-div0
  835 pts/0    00:00:00 do-div0 <defunct>
  836 pts/0    00:00:00 do-div0 <defunct>
  837 pts/0    00:00:00 do-div0 <defunct>
  838 pts/0    00:00:00 do-div0 <defunct>
  839 pts/0    00:00:00 do-div0 <defunct>
  840 pts/0    00:00:00 do-div0 <defunct>
  843 pts/0    00:00:00 do-div0 <defunct>
  846 pts/0    00:00:00 do-div0 <defunct>
  848 pts/0    00:00:00 do-div0 <defunct>
```

可以发现虽然子进程已经终止，但是在 `ps` 命令执行的时候依然可以被找到，那么在 cgroup 对 pid 进行限制的情况下，`fork()` 自然不能正常进行。



