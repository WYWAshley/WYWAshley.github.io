---
layout: post
title: shallow copy VS deep copy
categories: [Python]
description: shallow copy VS deep copy
keywords: Leetcode, Python
---

做一个总结

Python深拷贝和浅拷贝的区别，地址的复制还是值的复制

##  一、可变对象，不可变对象

可变对象是指，一个对象在不改变其所指向的地址的前提下，可以修改其所指向的地址中的值；

不可变对象是指，一个对象所指向的地址上值是不能修改的，如果你修改了这个对象的值，那么它指向的地址就改变了，相当于你把这个对象指向的值复制出来一份，然后做了修改后存到另一个地址上了，但是可变对象就不会做这样的动作，而是直接在对象所指的地址上把值给改变了，而这个对象依然指向这个地址。不可变对象有 int, float, complex, long, str, unicode, tuple。

 

## 二、深拷贝和浅拷贝需要注意的地方就是可变元素的拷贝

​		在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去，而是和原对象里的可变元素指向同一个地址，所以==在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。==

 

**举例说明：**

```python
#encoding=utf-8

import copy
a=[1,2,3,4,5,['a','b']]
#原始对象
b=a#赋值，传对象的引用
c=copy.copy(a)#对象拷贝，浅拷贝
d=copy.deepcopy(a)#对象拷贝，深拷贝
print "a=",a,"  id(a)=",id(a),"id(a[5])=",id(a[5])
print "b=",b,"  id(b)=",id(b),"id(b[5])=",id(b[5])
print "c=",c,"  id(c)=",id(c),"id(c[5])=",id(c[5])
print "d=",d,"  id(d)=",id(d),"id(d[5])=",id(d[5])
print "*"*70

a.append(6)#修改对象a
a[5].append('c')#修改对象a中的['a','b']数组对象
print "a=",a,"  id(a)=",id(a),"id(a[5])=",id(a[5])
print "b=",b,"  id(b)=",id(b),"id(b[5])=",id(b[5])
print "c=",c,"    id(c)=",id(c),"id(c[5])=",id(c[5])
print "d=",d,"      id(d)=",id(d),"id(d[5])=",id(d[5])
```

结果：

![img](https://img2018.cnblogs.com/blog/1214695/201810/1214695-20181004154546652-472885204.png)

列表a和b是赋值操作，两个对象完全指向同一个地址，a和b就是同一块地址的两个引用，其实就是一个东西，所以一个对象在修改**浅层元素（不可变）或深层元素（可变）**时，另一个对象也同时在变；

c是a进行浅拷贝生成的对象，可以看到a（或b）和c两个对象整体的id是不同的，但是里面的第5个元素-列表的地址却是相同的（指向同一个地址），所以b在浅层次元素层面（不可变）增加一个元素时，c并没跟着增加，但是b的第5个元素-列表在增加一个元素时，c的第5个元素也跟着增加了，这就是因为b和c的第5个元素-列表是指向同一个地址的，这个地址上的值变了，在两个地方会同时改变；

d的浅层次元素（不可变）和 深层次元素（可变）的地址和a,b,c都不一样，所以，a,b,c无论怎么修改，d都不会跟着改变，这就是深拷贝的结果。

通常复制的时候要用深拷贝，因为浅拷贝后，两个对象中不可变对象指向不同地址，相互不会改变，但是两个对象中的可变元素是指向相同的地址，一个变了，另一个会同时改变，会有影响（list是可变对象）。

```python
List1=[‘a’,’b’,’c’]
List2=[‘a’,’b’,’c’]
# 两个列表中的’a’的地址是相同的, id(list1[0])=id(list2[0])
# 但是两个列表的地址是不同的,id(list1)!=id(list2)
```