---
layout: post
title: 外部排序
categories: [算法]
description: 多路平衡归并排序+置换选择排序+最佳归并树
keywords: 
---

多路平衡归并排序（胜者树、败者树）+置换选择排序+最佳归并树	

## 一、初步介绍

我们了解一些插入排序、选择排序、归并排序等等，这些算法都属于内部排序算法，即排序的整个过程只是在内存中完成。而当待排序的文件比内存的可使用容量还大时，文件无法一次性放到内存中进行排序，需要借助于外部存储器（例如硬盘、U盘、光盘），这时就需要用到外部排序算法来解决。

外部排序算法由两个阶段构成：

1. 按照内存大小，将大文件分成若干长度为 L 的子文件（L 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；
2. 对得到的顺段进行合并，直至得到整个有序的文件为止。

<img src="/images/posts/External Sort/1.png"/>

* 对于外部排序算法来说，影响整体排序效率的因素主要取决于**读写外存的次数**，即访问外存的次数越多，算法花费的时间就越多，效率就越低。
* 而对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即**归并操作的次数越多，访问外存的次数就越多**。
* 一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，**归并的次数为：$s=log_k⁡m$（其中 s 表示归并次数）**。
* 所以，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：
  - **增加 k**-路平衡归并中的 k 值；
  - 尽量**减少 m **初始归并段的数量，即增加每个归并段的容量；

<br>

## 二、多路平衡归并排序算法（胜者树、败者树）

​	上述增加 k 值的想法引申出了多路平衡归并算法。但是经过计算得知，如果毫无限度地增加 k 值，虽然会减少读写外存数据的次数，但会增加内部归并的时间，得不偿失。

​	例如对于 10 个临时文件，当采用 2-路平衡归并时，若每次从 2 个文件中想得到一个最小值时只需比较 1 次；而采用 5-路平衡归并时，若每次从 5 个文件中想得到一个最小值就需要比较 4 次。以上仅仅是得到一个最小值记录，如要得到整个临时文件，其耗费的时间就会相差很大。

​	胜者树和败者树的区别就是：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方。而在比较过程中，都是拿胜者去比较。

<img src="/images/posts/External Sort/2.png"/>

​	因为树中每个非终端结点（除叶子结点之外的其它结点）中的值都表示的是左右孩子相比较后的较小值（谁最小即为胜者）。例如叶子结点 49 和 38 相对比，由于 38 更小，所以其双亲结点中的值保留的是胜者 38。然后用 38 去继续同上层去比较，一直比较到树的根结点。

<img src="/images/posts/External Sort/3.png"/>

​	如图所示为一棵 5-路归并的败者树，其中 b0—b4 为树的叶子结点，分别为 5 个归并段中存储的记录的关键字。 ls 为一维数组，表示的是非终端结点，其中存储的数值表示第几归并段（例如 b0 为第 0 个归并段）。ls[0] 中存储的为最终的胜者，表示当前第 3 归并段中的关键字最小。当最终胜者判断完成后，只需要更新叶子结点 b3 的值，即导入关键字 15，然后让该结点不断同其双亲结点所表示的关键字进行比较，败者留在双亲结点中，胜者继续向上比较。

​	为了防止在归并过程中某个归并段变为空，处理的办法为：可以在每个归并段最后附加一个关键字为最大值的记录。这样当某一时刻选出的冠军为最大值时，表明 5 个归并段已全部归并完成。（因为只要还有记录，最终的胜者就不可能是附加的最大值）

<br>

## 三、置换-选择排序算法

​	增加数量 m 的想法引申出了另一种外部排序算法：置换-选择排序算法。

​	如果要想减小 m 的值，在外部文件总的记录数 n 值一定的情况下，只能增加每个归并段中所包含的记录数 l。而对于初始归并段的形成，就不能再采用上一章所介绍的内部排序的算法，因为所有的内部排序算法正常运行的前提是所有的记录都存在于内存中，而内存的可使用空间是一定的，如果增加 l 的值，内存是盛不下的。

​	置换—选择排序算法的具体操作过程为：

1. 首先从初始文件中输入 6 个记录到内存工作区中；

2. 从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；

3. 然后将 MINIMAX 记录输出到归并段文件中；

4. 此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中；

5. 从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录；

6. 重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段；

7. 重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。

   <br>

   看图更好理解：

   <img src="/images/posts/External Sort/4.png"/>

   <img src="/images/posts/External Sort/5.png"/>

   <img src="/images/posts/External Sort/6.png"/>

   <img src="/images/posts/External Sort/7.png"/>

   当选不出 MINIMAX 值时，表示一个归并段已经生成，则开始下一个归并段的创建。

   <br>

   具体也可以用 败者树 数据结构实现，因为选择不小于旧的 MINIMAX 记录的最小值，所以增加序号：

   <img src="/images/posts/External Sort/8.png"/>

   <img src="/images/posts/External Sort/9.png"/>

   <img src="/images/posts/External Sort/10.png"/>

   <img src="/images/posts/External Sort/11.png"/>

   <img src="/images/posts/External Sort/12.png"/>

<br>

## 四、最佳归并数

​	举例子说明问题，现有通过置换选择排序算法所得到的 9 个初始归并段，其长度分别为：9，30，12，18，3，17，2，6，24。在对其采用 3-路平衡归并的方式时可能出现如图所示的情况：

<img src="/images/posts/External Sort/13.png"/>

​	假设在进行平衡归并时，操作每个记录都需要单独进行一次对外存的读写，那么图中的归并过程需要对外存进行读或者写的次数为：$9+30+12+18+3+17+2+6+24）*2*2=484$ （图 1 中涉及到了两次归并，对外存的读和写各进行 2 次）

​	从计算结果上看，其操作外存的次数恰好是树的带权路径长度的 2 倍。所以，对于如何减少访问外存的次数的问题，就等同于考虑如何使 k-路归并所构成的 k 叉树的带权路径长度最短，那么就想到了之前[信息论](https://github.com/WYWAshley/WYWAshley.github.io.git/2020/03/24/entropy/)里面提到过的——

* **霍夫曼树**

<img src="/images/posts/External Sort/14.png"/>

​	其对外存的读写次数为 $(2*3+3*3+6*3+9*2+12*2+17*2+18*2+24*2+30)*2=446$

​	通过以构建赫夫曼树的方式构建归并树，使其对读写外存的次数降至最低（k-路平衡归并，需要选取合适的 k 值，构建赫夫曼树作为归并树）。所以称此归并树为最佳归并树。

* **附加“虚段”的归并树**

  若 9 个初始归并段改为 8 个，在做 3-路平衡归并的时候就需要有一个结点的度为 2.为了使总的带权路径长度最短，正确的选择方法是：附加一个权值为 0 的结点（称为“虚段”），然后再构建赫夫曼树。

  虚段的设置只是为了方便构建赫夫曼树，在构建完成后虚段自动去掉即可。

  <img src="/images/posts/External Sort/15.png"/>

  在一般情况下，对于 k–路平衡归并来说，若 $(m-1)MOD(k-1)=0$，则不需要增加虚段；

  否则需附加 $k-(m-1)MOD(k-1)-1$ 个虚段。