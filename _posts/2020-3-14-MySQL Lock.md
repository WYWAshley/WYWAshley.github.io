---
layout: post
title: MySQL锁
categories: [SQL]
description: 
keywords: MyIsam, InnoDB, Lock
---

介绍 MySQL 数据库的两种存储引擎 MyIsam 和 InnoDB 处理事务时对数据加的锁

## 表锁（以MyIsam为例）

### 1. 加读锁

* ```show open tables;```   查看表上加过的锁

* ```lock table 表名 read(write), 表名2 read(write);```   手动增加锁

* ```unlock tables;```   释放表

  | session 1                | session 2                  |
  | ------------------------ | -------------------------- |
  | 给表加读锁               |                            |
  | 可以读取该表             | 也可以读取该表             |
  | 不可以查询其他未锁定的表 | 也可以查询或更新其他表     |
  | 不可以增删改该表         | 增删改该表会一直等待获得锁 |
  | 释放表锁                 | 获得锁，增删改成功         |

### 2. 加写锁

​		写锁会影响读锁和写锁，读锁不会影响读锁，会影响写锁

### 3. 分析表锁定

​		可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁定 ```show status like 'table%';```  其中 Table_locks_immediate 表示可以立即获取表级锁定的次数，即每次获取次数加一，==Table_locks_waited== 出现表级锁定争用而发生等待的次数，即此值高代表存在着严重的表级锁争用情况。

### 4. 总结

​		此外，Myisam的读写锁调度时写优先，这也是 **myisam 不适合做写为主的引擎**，因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远堵塞。可以优化，将大query拆分成小query，然后建立高效的索引加快检索。

<br/>

## 行锁（以InnoDB为例）

innoDB和Myisam 区别在于支持事务，采用行级锁

* 在不可重复读情况下，session 可以读到自己已修改但未提交的数据，**读己之所写**

* session1在修改的时候session2是不能修改同一行的，读取也是不可以的会一直等待，所以可以避免不可重复读的问题，只有session1提交之后session2才能修改这一行

* 但是不是同一行的可以同时修改，两边提交了的话都是会修改的

* **没有使用索引，行锁变表锁**

* 当我们用范围条件而不是想等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项（**该索引和主键聚集索引都要加**）加锁（record-key），对于键值在条件范围内但并不存在的记录叫做间隙**（gap-key）这是针对非唯一索引或者唯一索引的范围查询的**，合起来叫做next-key。间隙锁会是某些不存在的键值被无辜的锁定，而造成在锁定的时候无法插入锁定简直范围内的任何数据，在某些场景下会造成很大的危害。

* ==当前读== ```select * from a where a.b=400 for update```  在扫描到的任何索引记录上加**排它的next-key lock**。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。

  ==当前读==```select * from a where a.b=400 lock in share mode;```  在扫描到的任何索引记录上加共享的**（shared）next-key lock**，其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。如果事务对某行数据加上共享锁之后，可进行读操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。

  ==快照读==```select ...from...```  查询数据不加任何类型的锁，**所以并不是加了排他锁这行数据就不能被读取了。**

  ```update..where  delete from..where```  在扫描到的任何索引记录上加next-key lock

  ```insert into..```  简单的insert会在insert的行对应的索引记录上加一个排它锁，这是一个record lock，并没有gap，所以并不会阻塞其他session在gap间隙里插入记录。假设发生了一个唯一键冲突错误，那么将会在重复的索引记录上加读锁。当有多个session同时插入相同的行记录时，如果另外一个session已经获得该行的排它锁，那么将会导致死锁。这是改用```INSERT ... ON DUPLICATE KEY UPDATE ```这种 sql 和 insert 加锁的不同的是，如果检测到键冲突，它直接申请加排它锁，而不是共享锁，不会发生上述死锁。

* ==意向锁==的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”，**为了实现多粒度锁机制**（白话：为了表锁和行锁都能用）。因为当表中的几行被锁定了，另一个命令想要获得表锁时需要遍历整表确定是否有行级锁，那么在行级锁申请之前先申请一个表的意向锁就可以了。

* ```show status like 'innodb_row_lock%'``` 中的 ==InnoDB_row_lock_waits== 代表行锁冲突次数， ==Innodb_row_lock_current_waits== 正在等待锁定的数量。可以用 ```show profile;```查看为什么有那么多锁

![image-20200313215132343](C:\Users\yuwen\AppData\Roaming\Typora\typora-user-images\image-20200313215132343.png)

<br/>

## 乐观锁

* 悲观锁

  当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。

​		悲观并发控制实际上是==“先取锁再访问”==的保守策略，为数据处理的安全提供了保证。

<img src="/images/posts/MySQL Lock/1.jpg"/>

​			但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外			还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理			那行数据。

<br/>

* 乐观锁

  乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。

  相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。

<img src="/images/posts/MySQL Lock/2.jpg"/>

​		乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，		==直到提交的时候才去锁定==，所以不会产生任何锁和死锁。

<br/>

* 悲观锁实现方式

  上述说的表级锁、行级锁都是悲观锁的实现，不再赘述

  <br/>

* 乐观锁实现方式

  使用乐观锁就不需要借助数据库的锁机制了。

  乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：==冲突检测和数据更新==。其实现方式有一种比较典型的就是**CAS(Compare and Swap)**。

  CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。比如扣减库存问题，通过乐观锁可以实现如下：

<img src="/images/posts/MySQL Lock/3.jpg"/>

<br/>

* 乐观锁使用

  以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。

  以上更新语句存在一个比较重要的问题，即传说中的**ABA问题**。

  比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中取出库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。

<img src="/images/posts/MySQL Lock/4.jpg"/>

* 版本控制

  有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的==version字段==。乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。改为以下方式即可：

  除了version以外，还可以使用时间戳，因为==时间戳==天然具有顺序递增性。

<img src="/images/posts/MySQL Lock/5.jpg"/>

<img src="/images/posts/MySQL Lock/6.jpg"/>

* 减小乐观锁粒度
   以上SQL其实还是有一定的问题的，就是一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。

  有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：

<img src="/images/posts/MySQL Lock/7.jpg"/>

* 如何选择

  在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。

  乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。

  悲观锁依赖数据库锁，效率低。更新失败的概率比较低。

  随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。